---
layout: post
title: "设计模式-策略模式"
description: ""
category: "program"
tags: [设计模式]
---
{#welcome}
=====================
### 目录文件：

[TOC]

### 模拟鸭子应用
使用OO技术设计鸭子超类，并让各种子类继承此超类。
但是公司决定加入新的功能fly()
怎么解决？

### 想到继承
1. 直接加入超类
> 有些子类会获得不属于它的方法，比如橡皮鸭就无法飞
2. 覆盖子类方法
> 被迫检查子类方法是否需要覆盖，容易出错

### 接口如何
设计一个flyable()接口，并用DUCK的子类实现它
>  实现放在子类中，实现一改变就得对所有的子类修改代码

***  Java接口不具有实现代码，所以直接继承接口无法达到代码的复用。***


### 软件开发的不变真理
把变化的部分取出并”封装“起来，以便以后要以轻易地改动工扩充，好也让其它部分不会受到影响。
> 设计原则：
> 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起

### 分开变化和不变的部分
把fly() 和quack类从duck类中取出，建立一组新类来代表每个行为。

### 设计鸭子的行为
设计一组其他类专门实现Flying 与Quacking接口的行为类来实现行为接口。
实现不会绑死在鸭子的子类中，换句话说，特定的具体行为编写在实现了FlyBehavio与QuakcBehavior的类中

> 设计原则：
> 针对接口编程，而不是针对实现编程
> 针对接口编程真正的意思是针对**超类型(supertype)**编程
> 超类型可以是抽象类或接口

### 动态设置行为
加上settter method来动态设定鸭子的行为，而不是在构造器中实例化

### 封装行为的大局观
鸭子根据子类不同会有一组不同的行为
在编程角度解决一个问题会有不同解决方法，也就是“算法族”
### ”有一个“比”是一个“更好
？这边讲的有一个是一个我不太理解？
“有一个”关系相当有趣：每一鸭子都有一个FlyBehavior和一个QuackBehavior，好将飞行和呱呱叫委托它们代为处理。
这种做法和“继承”不一样的地方在于鸭子的行为不是继承来的，而是和适当的行为对象“组合”来的（就是实现接口）

> 设计原则：
> 多用组合，少用继承

Q&A：
Q:猎人用鸭鸣器模拟出鸭叫声，以引诱野鸭，你如何实现这个鸭鸣器，不继承Duck类？
A:和本文说的一样，实现叫的接口

### 为什么要用设计模式
设计出弹性的、可复用的、可维护的系统
要诀就在于想到系统以后可能需要的变化以及应付变化的原则